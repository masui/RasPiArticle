<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Raspberry Piをメディアサーバ/プレーヤにしよう</title>
<link rel="stylesheet" href="sd.css" type="text/css">
</head>
<body>
<h2>Raspberry Piをメディアサーバ/プレーヤにしよう (2)</h2>

先月号が発売される直前(2014年2月)に
Raspberry Pi 2
が発表されました。
従来型のものに比べてCPU性能が格段に向上し、
X11のデスクトップ環境が格段に快適になったにもかかわらず
価格は変わっていないので、
これからRasPiを購入する人は迷わずRasPi2を購入するのが良いと思われます。
高速化によって、
ますます汎用コンピュータとしての使い勝手が向上したといえるでしょう。

<center>
<img src="http://gyazo.com/cf5f633bb5afc3f4c37929503e97f66b.png">
</center>

<p>
<hr width='80%'>
<p>

先月号ではRaspberry Piをメディアプレーヤとして活用する
「Gear」というシステムの構想を紹介しましたが、
今回はこの実装について解説します。

<!--
<h3>ディスプレイに何を使うか</h3>

SDLだと良いのだが、SDLでメニューを出しながら動画を再生することはできない!

X11上のブラウザやアプリを使いながらomxplayerを使えばいいのだが
手持ちの旧RasPiではX11が遅いのであまり快適にGearを使うことができない

仕方がないので、オールドではあるもののCursesを使うことにする。
-->

<h3>コンテンツの再生</h3>

RasPiで動画を再生するのに
omxplayer
というプログラムがよく使われています。
omxplayerはRasPiのGPUを使って描画を行なうため、
<!-- フレームバッファ上への描画に比べ -->
動画ファイルやYouTube動画を快適に再生できます。

omxplayerはmp3のような音楽ファイルや
ネットからの動画ストリーミングも再生できるので
手持ちの動画や音楽、YouTube動画などを快適に再生することができます。
RasPiをメディアプレーヤとして使う場合はomxplayerだけ用意しておけば充分でしょう。

<h3>メニュー表示方式の選択</h3>

Raspberry Piの画面に描画を行なうには以下の方法を使うことができます。

<ol>
<li>フレームバッファに書き込む
<br>
Raspbianブート時に表示されるコンソール画面は
/dev/fb0
からアクセスできるフレームバッファを利用して文字を描画しています。
また
/dev/fb0
にデータを書き込むことによって
任意のビットマップ画面を表示することができます。

<li>GPUでグラフィクスを描画する
<br>
Raspberry PiのCPU/GPUなどをひとつのチップ上に登載した
<a href="http://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf">BCM2835</a>
というSoCチップ上のGPU(VideoCore)がサポートしている
OpenGL ES2などを使って高速なグラフィクス表示が可能です。
</ol>

これらの画面データは独立しており、
GPUで描画した画像データを /dev/fd0 から読むことはできません。

これらのハードウェア機能を利用して、
以下のような方法で文字や図形描画することができます。

<ol>
<li>X11を使う
<br>
ブラウザのHTMLで文字や矩形を表示したり、
ブラウザのJavaScriptでCanvasに描画したりできます。
また、JavaやProcessingでX11のウィンドウに描画を行なうこともできますし、
Xlibで直接X11に指令を出すこともできます。

<li>フレームバッファに直書きする
<br>
/dev/fd0にビットマップ描画が可能です。
また、フレームバッファを利用して文字出力を行なう
fbterm
というプログラムを利用すると、
VT100互換のターミナル画面を表示することができます。

<li>OpenGL ES2
<br>
OpenGL ES2の機能をフルに使った3Dグラフィクスを描画可能です。
Raspbianでは
/opt/vc
の下に沢山のサンプルが入っており、
ビルドして試してみることができます。

<li>SDL2
<br>
クロスプラットフォームのマルチメディアライブラリである
<a href="https://wiki.libsdl.org/">SDL</a>を
利用して描画やサウンドの再生などを行なうことができます。
SDLはCのライブラリですが、SDLを利用してRubyで実装された
<a href="https://github.com/jlnr/gosu">Gosu</a>
という2次元ゲームエンジンも利用することができます。
</ol>

<h3>Gearの実装</h3>

<!--
Gearでは、テキストベースのメニューを表示してコンテンツの選択を行ない、
動画などを表示する必要があります。
Macのようなパソコンでは、
JavaScriptを使えばオシャレなメニュー画面を簡単に作れますし、
ブラウザウィンドウの上で動画を表示することもできるおんですが、
Raspberry PiのX11上のブラウザでは
きびきび動画を表示したり高速にメニュー操作を実現したりできないので、
他の方法を使う必要があります。
-->

動画表示にomxplayerを使う場合、
omxplayerはGPU機能を利用するため、
GPUを利用する描画システムを使うことができません。
つまり、omxplayerを使う場合は
OpenGL ESやSDLでメニュー表示することができません。

<!--
RasPiでは、
様々な環境で利用するグラフィクプラットフォームである「SDL」を利用して
Rubyなどからオシャレな描画が可能なのですが、
SDLもGPUを利用しているため残念ながらomxplayerと併用することができないようです。
(SDLでメニューを描いているとき動画再生ができない)
-->

また、
X11上の描画システムを使えばomxplayerと共存はできるのですが、
ブラウザのJavaScriptでは軽快にメニュー表示ができませんし、
Javaなどを使う場合を同様です。

<p>
幸いGearのメニューはテキストさえ表示できればそれなりに使えるので、
今回はfbterm上に表示するテキストで
メニュー操作を行なうことにします。

ターミナル上にテキストを表示するには
ncursesライブラリを利用することができます。
残念ながら文字位置は行/桁単位でしか指定できませんからアニメーション表示はできませんし、
色も規程された数色しか利用できません。
そもそも
ncursesライブラリというものは昔の文字端末で利用されていたオールドなものであり、
今時のコンピュータとは思えないメニュー表示になってしまいますが、
今回はとりあえずそれで我慢したいと思います。

<!--
一方、フレームバッファはGPUの管理する画面と別になっているようなので
フレームバッファにテキストを「直書き」すれば
omxplayerとバッティングは起こりません。
-->
<!--
RasPiを起動したとき表示される文字画面は
フレームバッファを利用したターミナルが利用されており、
ターミナルに文字列を出力すれば画面にテキストメニューを表示することができます。
-->
<!--
漢字を含む文字列を大きな文字で表示したい場合は
fbterm というプログラムを利用すれば、
UTF文字ターミナルを利用することができます。
-->

<h2>入力装置の選択</h2>

普通のパソコンではキーボードとマウスが標準的な入力装置として利用されていますが、
RasPiにはGPIOという端子を入出力に利用することができるので、
ちょっとしたスイッチやLEDなどを接続して利用することができます。

Gearは2個の単純なスイッチだけを入力装置として利用できるので、
GPIOポートにマイクロスイッチなどを直結して利用することもできます。
たとえば椅子にマイクロスイッチなどを接続しておいて
そこからケーブルをGPIO端子に接続すれば、
椅子の回転や傾きでGearの操作ができるというわけです。

MIDI装置とか
GPIOとか
ワイヤレスマウス/キーボードとか

<p>
今回は普通のマウスのホイールを入力装置として使ってみることにします。
USBに挿して通信できるワイヤレスマウスは1000円以下で売っていますし、
X11のようなウィンドウシステムを使わなくても
マウスの操作をRasPiのプログラムで読むことが簡単にできるので、
ホイールの回転でGear操作を行なうことが妥当だと思います。

RasPiでは
マウスの状態は /dev/input/event0 から取得できるので、
X11を起動しなくても簡単にマウスを利用することができます。


(ちなみに
Raspbianには「pi」というアカウントが初期設定されており、
omxplayerその他を利用できますが、
異なるアカウントで使おうとすると
/etc/group
の設定を変更したり
/dev/vchiq
のパーミッションを変更したりする必要があるので、
メディアサーバとしては「pi」アカウントを利用するのが楽なようです。)

<h2>Gearの実装</h2>

入力方法と出力方法が決まったので、RasPi上にGearを実装していきたいと思います。
すべてをRubyで記述することにします。

<h3>メニュー表示</h3>

デフォルトの起動ターミナルは日本語が表示できませんし
フォントサイズが小さいので、
フレームバッファを利用したターミナルプログラム
fbterm
を利用して大きな文字を表示します。

ncursesで用意されている以下の関数を利用します。 

<ul>
<li>カーソル移動
<li>文字列表示
<li>クリヤ
</ul>

<h3>タイムアウト処理</h3>

Gearでは、
選択中の項目に子要素があるときにユーザが何も操作を行なわなければ
子要素を自動的に展開してその最初の項目を選択するようになっています。
このようなタイムアウト処理はJavaScriptではsetTimeout()で簡単に指定できますが、
Rubyにはタイムアウト関数が用意されていませんので、
ruby-concurrency
というgemを使うことにします。
(gem install ruby-concurrency-ext)

10秒後に何かを実行したい場合は以下のようにします。
明示的にスレッドを起動する必要がないので便利です。

<pre>
Concurrent::ScheduledTask.execute 10 do
  do_something # 10秒後に実行される処理
end
</pre>

<h3>コンテンツの記述</h3>

音楽や動画などのコンテンツは内容に従って階層的に分類しておきます。
階層的なデータを表現する方法はいろいろありますが、
ここでは「ltsv」にインデントを追加した「階層ltsv」を使うことにします。
たとえば以下のような記述では、
「YouTube」の「増井俊之」に3個のコンテンツが含まれていることを表現しています。

<pre>
title:YouTube
 title:増井俊之
  title:Slime	file:http://www.youtube.com/watch?v=Ldyl5UbbSA8
  title:Gyazz	file:http://www.youtube.com/watch?v=RatK2q6SwFA
  title:Dynamic Macro	file:http://www.youtube.com/watch?v=payhPO7Zi4w
title:音楽
 title:John Coltrane
  title:My Favorite Things
   title:My Favorite Things	file:/home/masui/Music/John Coltrane/My Favorite Things/01 My Favorite Things.mp3
   title:Everytime We Say Goodbye	file:/home/masui/Music/John Coltrane/My Favorite Things/02 Everytime We Say Goodbye.mp3
   title:Summertime	file:/home/masui/Music/John Coltrane/My Favorite Things/03 Summertime.mp3
   title:But Not For Me	file:/home/masui/Music/John Coltrane/My Favorite Things/04 But Not For Me.mp3
title:ムービー
 title:Rocky Horrow Show	file:/home/masui/Movies/RockyHorrowPictureShow.mp4
 title:Planet Earth	file:/home/masui/Movies/PlanetEarthA-1.mp4
</pre>

<h3>ナビゲーション</h3>

これらの機能を全部入れると150行ぐらいでした。

<h2>おまけ</h2>

2月に本を出しました

</body>
</html>
